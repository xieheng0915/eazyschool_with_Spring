### Basic architecture (with RDS database)
- UI: html, embed thymeleaf tag into html, th:object will match to model
- Model: Model matches to database table
- Repository: deal with all the DB operation, by inherientence from CRUDRepository, JpaRepository, developers don't need to write logic any more.(embeded hibernate) and with the naming rule, developers can just declare the abstract methods, like getByEmail, updateByName etc.
- Service: Service can aggregate all the DB operation and return the model object
- Controller: get object from UI, call Service to do backend operation, or send back object with data to UI.

#### features across Spring all layers:
- Log features: Sl4j
- Security/audit features
#### Other supporting features:
- annotation
- validation
- rowmappers
- constants

### JPA features
JPA has pre-installed hibernate, can save some operations.
- In model layer, mark the auto-generation annotations, like below:
```
   @Id  
   @GeneratedValue(strategy = GenerationType.AUTO,generator = "native")  
   @GenericGenerator(name = "native", strategy = "native")  
   @Column(name = "contact_id")  
   private int contactId;  
```
- upperline model, added @MappedSuperclass to include elements.
- change Repository class to interface and extends CrudRepository.
- Delete all the CRUD operation in repository layer
- Use default CRUD methods directly in service or controller layer, like findAll, findById, etc
- For those non-default methods, just declare the method in repository without implementation by following the camel naming rule, eg.:  
```
@Repository
public interface ContactRepository extends CrudRepository<Contact,Integer> {
List<Contact> findByStatus(String status);}
```
- Add @EnableJpaRepositories("com.eazybytes.eazyschool.repository") and @EntityScan("com.eazybytes.eazyschool.model") in main application to inform where to scan features.


### Audit operation
- in model.BaseEntity, added @createdDate,@createdby,@LastedModifiedDate, @LastModifiedBy annotations to inform Spring auto-generate these columns. 
- added audit.AuditAwareImpl class, to monior the change and auto-generate data, date is generated according to system time, while createdby, updatedby are generated by authentication data.
- added "@EnableJpaAuditing(auditorAwareRef = "auditAwareImpl")" in main module to inform the location of auditAware features
- deleted all the setCreatedby,setCreatedAt, setUpdatedBy, setUpdatedAt operations in service layer.


### Customize annotation
- Add annotation package and customized annotation class, extend JpaRepository, designate the class to implememnt validation 
- Add validation package and implemented validation class, implement the validation logic
- Add annotation into related model class to enable validation (refer to Person.java)

### Model relationship
Model matches to database tables, and like tables, has OneToOne, OneToMany, ManyToMany, ManyToOne relationships

- mark the relation in mode class(sample): 
```
    @OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.PERSIST,targetEntity = Roles.class)
    @JoinColumn(name = "role_id", referencedColumnName = "roleId", nullable = false)
    private Roles roles;

    @OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL,targetEntity = Address.class)
    @JoinColumn(name = "address_id", referencedColumnName = "addressId", nullable = true)
    private Address address;
```

### Customize authentication logic
- If you want to use **Spring boot authentication feature**, add @EnableWebSecurity annotation in ProjectSecurityConfig:   
```ProjectSecurityConfig
@Configuration
@EnableWebSecurity
@ComponentScan("com.eazybytes.eazyschool.security")
public class ProjectSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private EazySchoolUsernamePwdAuthenticationProvider authProvider;
    
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenicationProvider(authProvider);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception{
        http.authorizeRequests().anyRequest().authenticated().and().httpBasic();
    }
}
```

- (1)Add security package and EazySchoolUsernamePwdAuthenticationProvider.java, implement auth logic
- (2)In ProjectSecurityConfig.java add passwordEncoder bean, here define the passowrd encryption(hash) way. 
```
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
```
Encryption types:   
```
    - NoOpPasswordEncoder (no hashing)
    - StandardPasswordEncoder
    - Pbkdf2PasswordEncoder
    - BCryptPasswordEncoder(most commonly used)
    - SCryptPasswordEncoder  
```
- (3)In PersonService add:  
```
    // encode password
    person.setPwd(passwordEncoder.encode(person.getPwd()));
```
- (4)Add below setting in application.properties file, to disable automatic spring authentication, otherwise at the timing of registration, password will be encoded and this will triger validation error:  
```
spring.jpa.properties.javax.persistence.validation.mode=none
```

### OneToMany Relationship and display classes
##### OneToMany Relationship key configuration

```Person.java (Model)
//annotation on top of Person.java
@Getter
@Setter
@Entity
```
```Person.java (Model)
// OneToMany related annotation for eazyClass
    @ManyToOne(fetch = FetchType.LAZY,optional = true)
    @JoinColumn(name = "class_id", referencedColumnName = "classId",nullable = true)
    private EazyClass eazyClass;
```
```EazyClass.java (Model)
@Getter
@Setter
//@Data Due to Lombok's bug, alternative solution, change @Data to @Getter and @Setter
@Entity
@Table(name = "class")
public class EazyClass extends BaseEntity{

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO,generator = "native")
    @GenericGenerator(name = "native",strategy = "native")
    private int classId;

    @NotBlank(message = "Name must not be blank")
    @Size(min = 3,message = "Name must be at least 3 characters long")
    private String name;

    @OneToMany(mappedBy = "eazyClass", fetch = FetchType.LAZY,
            cascade = CascadeType.PERSIST,targetEntity = Person.class)
    private Set<Person> persons;
}
```
##### Add Classes and students
- (1) Add Class section in dashboard.html, add configuration in ProjectSecurityConfigure.class
- (2) Add AdminController, define the action of clicking the icon 
- (3) Add Model eazyClass, add eazyclass variable in Person Model
- (4) Add EazyClassRepository interface, extend JpaRepository<EazyClass, Integer>
- (5) Add tables: eazyClass table, add class_id in Person table
- (6) Configure annotation to define OneToMany relationship on Person and eazyClass Model
- (7) Create eazyClass.html with modal and CSS section
- (8) Implement "add class" feature in AmdinController
- (9) Add "delete" button action in AdminController
- (10) Add "displayStudents" action in AdminController
- (11) Add students.html and css
- (12) Implement "Add new students", "delete students" features

### ManyToMany Relationship
##### ManyToMany Relationship key configuration
```Person.java(model)
    @ManyToMany(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST)
    @JoinTable(name = "person_courses",
        joinColumns = {
            @JoinColumn(name = "person_id", referencedColumnName = "personId")},
        inverseJoinColumns = {
            @JoinColumn(name = "course_id", referencedColumnName = "courseId")})
    private Set<Courses> courses = new HashSet<>();
```
```courses.java (model)
    @ManyToMany(mappedBy = "courses", fetch = FetchType.EAGER, cascade = CascadeType.PERSIST)
        private Set<Person> persons = new HashSet<>();
    }
```
##### Add courses (admin side)
- (1) Add courses section in dashboard
- (2) ProjectSecurityConfig (Omit here, same as classes)
- (3) Add Courses model with ManyToMany annotation configuration
- (4) Add ManyToMany annotation in Person model
- (5) Add courses tabel and middle table: person_courses (sql)
- (6) Add courseRepository
- (7) In AdminController, add displayCourses, addStudentToCourse, deleteStudentFromCourse 
- (8) Add courses_secure.html (courses list html) and courses_student.html (student list under particular course)

##### Add courses (student side)
- (1) Add courses section in dashboard
- (2) Add StudentController, displayCourses method
- (3) Add courses_enrolled.html  
  (_Since no new table added, no model needed, repository as well._)

### Sorting
- **Static Sorting:** Use name rule, by default, follow ascending sorting(**No need to change inheritended repository to PagingAndSortingRepository** )
```CourseRepository.java
@Repository
public interface CoursesRepository extends JpaRepository<Courses, Integer> {

    /*
    Spring Data JPA allows us to apply static sorting by adding the OrderBy keyword
    to the method name along with the property name and sort direction (Asc or Desc).
    * */
    List<Courses> findByOrderByNameDesc();

    /*
    The Asc keyword is optional as OrderBy, by default,
    sorts the results in the ascending order.
    * */
    List<Courses> findByOrderByName();
}
```
```ContactController.java
    @GetMapping("/displayCourses")
    public ModelAndView displayCourses(Model model) {
        List<Courses> courses = coursesRepository.findByOrderByNameDesc();
    //...
    }
```
        
- **Dynamic Sorting:** Use Sort.by("name).descending().and(Sort.by("age"));

```ContactController.java
  @GetMapping("/displayCourses")
  public ModelAndView displayCourses(Model model) {
  List<Courses> courses = coursesRepository.findAll(Sort.by("name").descending());
```

### Pagination

- (1) Inherit PagingAndSortingRepository, add Pageable in JdbcTemplate method as below
```
@Repository
public interface ContactRepository extends PagingAndSortingRepository<Contact, Integer>, CrudRepository<Contact, Integer> {

    Page<Contact> findByStatus(String status, Pageable pageable);

}
```
- (2) Control the UI related params in controller as below, (please pay attention to reverseSortDir)
```ContactController.java
    @RequestMapping("/displayMessages/page/{pageNum}")
    public ModelAndView displayMessages(Model model,
            @PathVariable(name = "pageNum") int pageNum,@RequestParam("sortField") String sortField,
                                        @RequestParam("sortDir") String sortDir) {
        Page<Contact> msgPage = contactService.findMsgsWithOpenStatus(pageNum,sortField,sortDir);
        List<Contact> contactMsgs = msgPage.getContent();
        ModelAndView modelAndView = new ModelAndView("messages.html");
        model.addAttribute("currentPage", pageNum);
        model.addAttribute("totalPages", msgPage.getTotalPages());
        model.addAttribute("totalMsgs", msgPage.getTotalElements());
        model.addAttribute("sortField", sortField);
        model.addAttribute("sortDir", sortDir);
        model.addAttribute("reverseSortDir", sortDir.equals("asc") ? "desc" : "asc");
        modelAndView.addObject("contactMsgs",contactMsgs);
        return modelAndView;
    }
```
- (3) Add tags and variables in html and css
  - (3.1) Clickable title of the message list table
  - (3.2) Pagination link in the bottom of th message table, highlight the active page, enable/disable page moving button
```Clickable title
<table class="table table-striped dataTable">
            <thead class="table-dark">
            <tr>
                <th class="sorting" scope="col">
                    <a th:href="@{'/displayMessages/page/' + ${currentPage} + '?sortField=name&sortDir=' + ${reverseSortDir}}">Name</a>
                </th>
                <th class="sorting" scope="col">
                    <a th:href="@{'/displayMessages/page/' + ${currentPage} + '?sortField=mobileNum&sortDir=' + ${reverseSortDir}}">Mobile Num</a>
                </th>
                <th class="sorting" scope="col">
                    <a th:href="@{'/displayMessages/page/' + ${currentPage} + '?sortField=email&sortDir=' + ${reverseSortDir}}">Email</a>
                </th>
                <th class="sorting" scope="col">
                    <a th:href="@{'/displayMessages/page/' + ${currentPage} + '?sortField=subject&sortDir=' + ${reverseSortDir}}">Subject</a>
                </th>
                <th class="sorting" scope="col">
                    <a th:href="@{'/displayMessages/page/' + ${currentPage} + '?sortField=message&sortDir=' + ${reverseSortDir}}">Message</a>
                </th>
                <th scope="col"></th>
            </tr>
            </thead>
```
```pagination
<!-- pagination -->
    <div class="pagination-style text-center mt-5">
        <ul>
            <li>
                <a th:if="${currentPage > 1}" th:href="@{'/displayMessages/page/' + ${currentPage - 1}+'?sortField=' + ${sortField} + '&sortDir=' + ${sortDir}}">
                    <span class="fa fa-angle-double-left" aria-hidden="true"></span>
                </a>
                <a th:unless="${currentPage > 1}" class="not-allowed" disabled="">
                    <span class="fa fa-angle-double-left" aria-hidden="true"></span>
                </a>
            </li>
            <span th:each="i: ${#numbers.sequence(1, totalPages)}">
            <li>
                <a th:if="${currentPage != i}" th:href="@{'/displayMessages/page/' + ${i}+'?sortField=' + ${sortField} + '&sortDir=' + ${sortDir}}">[[${i}]]</a>
                <a class="active" th:unless="${currentPage != i}">[[${i}]]</a>
            </li>
            </span>
            <li>
                <a th:if="${currentPage < totalPages}" th:href="@{'/displayMessages/page/' + ${currentPage + 1}+'?sortField=' + ${sortField} + '&sortDir=' + ${sortDir}}">
                    <span class="fa fa-angle-double-right" aria-hidden="true"></span>
                </a>
                <a th:unless="${currentPage < totalPages}" class="not-allowed" disabled="">
                    <span class="fa fa-angle-double-right" aria-hidden="true"></span>
                </a>
            </li>
        </ul>
    </div>
    <!-- //pagination -->
```

- (4) Set default view in dashboard.html messsage icon
```dashboard.html
<div class="col-sm-6 col-lg-3" sec:authorize="hasRole('ROLE_ADMIN')">
  <a th:href="@{/displayMessages/page/1?sortField=name&sortDir=desc}">
```
- (5) Recover the default view: 
```
@RequestMapping(value = "/closeMsg",method = GET)
    public String closeMsg(@RequestParam int id) {
        contactService.updateMsgStatus(id);
        return "redirect:/displayMessages/page/1?sortField=name&sortDir=desc";
    }
```
- (6) Change configuration 
```
.requestMatchers("/displayMessages/**").hasRole("ADMIN")
```

### Customize Query
- NamedQuery: to define JPQL which uses model field to create SQL 
- NamedQueryNative: to define native Query

##### Use @Query to write JPQL and NativeQL
- (1) for select SQL, Modify Repository with Query annotation and self-defined SQL
```ContactRepository.java
    // JPQL 
    @Query("SELECT c FROM Contact c WHERE c.status = :status") 
    // Native QL
    //@Query(value = "SELECT * FROM contact_msg WHERE status = :status",nativeQuery = true) 
    Page<Contact> findByStatus(@Param("status") String status, Pageable pageable);
```
**# For native query, "SELECT * FROM contact_msg c WHERE c.status =" doesn't work here, remove "c".**  

- (2) for Update/Delete/Insert, add @Modifying and @Transaction annotation, @Transaction will ensure roll-back in failure case
```ContactRepository.java
    @Transactional
    @Modifying
    @Query("UPDATE Contact SET status = ?1 WHERE contactId = ?2")
    int updateStatusById(String status, int id);
```
And update service layer where use this part, because native JPA repository use save instead of update to update table.
```
    public boolean updateMsgStatus(int contactId, String updatedBy){
        boolean isUpdated = false;
        /*
        Optional<Contact> contact = contactRepository.findById(contactId);
        contact.ifPresent(contact1 -> {
            contact1.setStatus(EazySchoolConstants.CLOSE);
            //contact1.setUpdatedBy(updatedBy);
            //contact1.setUpdatedAt(LocalDateTime.now());
        });
        Contact updatedContact = contactRepository.save(contact.get());
        */
        int rows = contactRepository.updateStatusById(EazySchoolConstants.CLOSE,contactId);
        //if( null != updatedContact && updatedContact.getUpdatedBy() != null){
        if(rows > 0){
            isUpdated = true;
        }
        return isUpdated;
    }
```
##### Use @NamedQuery and @NamedQueryNative to create self-defined JPQL/nativeQL
- (1) Define SQL in model
```
@SqlResultSetMappings({
        @SqlResultSetMapping(name = "SqlResultSetMapping.count", columns = @ColumnResult(name = "cnt"))
})
@NamedQueries({
        @NamedQuery(name = "Contact.findOpenMsgs",
                query = "SELECT c FROM Contact c WHERE c.status = :status"),
        @NamedQuery(name = "Contact.updateMsgStatus",
                query = "UPDATE Contact c SET c.status = ?1 WHERE c.contactId = ?2")
})
@NamedNativeQueries({
        @NamedNativeQuery(name = "Contact.findOpenMsgsNative",
                query = "SELECT * FROM contact_msg c WHERE c.status = :status"
                ,resultClass = Contact.class),
        @NamedNativeQuery(name = "Contact.findOpenMsgsNative.count",
                query = "select count(*) as cnt from contact_msg c where c.status = :status",
                resultSetMapping = "SqlResultSetMapping.count"),
        /*Spring Data JPA doesnâ€™t support dynamic sorting for native queries.
        Doing that would require Spring Data to analyze the provided statement and generate
        the ORDER BY clause in the database-specific dialect. This would be a very complex operation
        and is currently not supported by Spring Data JPA.*/
        @NamedNativeQuery(name = "Contact.updateMsgStatusNative",
                query = "UPDATE contact_msg c SET c.status = ?1 WHERE c.contact_id = ?2")
})
```
- (2) Define abstract method in repository by using customized sql name
```ContactRepository.java
    Page<Contact> findOpenMsgs(@Param("status") String status, Pageable pageable);

    @Transactional
    @Modifying
    int updateMsgStatus(String status, int id);

    @Query(nativeQuery = true)
    Page<Contact> findOpenMsgsNative(@Param("status") String status, Pageable pageable);

    @Transactional
    @Modifying
    @Query(nativeQuery = true)
    int updateMsgStatusNative(String status, int id);
```
- (3) Use method and encapsulate in the upper layer method in service layer or controller layer
```
    public Page<Contact> findMsgsWithOpenStatus(int pageNum,String sortField, String sortDir){
        int pageSize = 5;
        Pageable pageable = PageRequest.of(pageNum - 1, pageSize,
                sortDir.equals("asc") ? Sort.by(sortField).ascending()
                        : Sort.by(sortField).descending());
        Page<Contact> msgPage = contactRepository.findOpenMsgs(
                EazySchoolConstants.OPEN,pageable);
        return msgPage;
    }

    public boolean updateMsgStatus(int contactId){
        boolean isUpdated = false;
        int rows = contactRepository.updateMsgStatusNative(EazySchoolConstants.CLOSE,contactId);
        if(rows > 0) {
            isUpdated = true;
        }
        return isUpdated;
    }
```